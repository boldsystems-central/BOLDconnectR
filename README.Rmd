---
output: github_document
always_allow_html: yes
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# BOLDconnectR

<!-- badges: start -->
<!-- badges: end -->

BOLDconnectR is a package designed for **retrieval**, **transformation** and **analysis** of the data available in the *Barcode Of Life Data Systems (BOLD)* database. This package provides the functionality to obtain public and private user data available in the database in the *Barcode Core Data Model (BCDM)* format. Data include information on the **taxonomy**,**geography**,**collection**,**identification** and **DNA sequence** of every submission. 

```{r necessary packages install,include=FALSE}
library(devtools)
library(utils)
library(base)
```

## Installation

The package can be installed using `devtools::install_github` function from the `devtools` package in R (which needs to be installed before installing BOLDConnectR). *This package currently exists as a private repo and thus has an authorization token*.

```{r setup,warning=FALSE,message=F}

devtools::install_github("https://github.com/sameerpadhye/BOLDconnectR.git",
                         auth_token = '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')

```

```{r BOLDconnectR import,warning=FALSE,message=FALSE}
library(BOLDconnectR)
```

*NOTE* One of the functions in the package requires `msa` and `Biostrings` packages installed and imported beforehand. `msa` is installed using `BiocManager` package (Details of the function given below).
```{r msa install,warning=FALSE,message=FALSE}

if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")

BiocManager::install("msa")
BiocManager::install("Biostrings")

library(msa)
library(Biostrings)

```

## BOLDconnectR has 9 functions currently:

1. bold.fields.info
2. bold.fetch
3. bold.public.search
4. bold.data.summarize
5. *bold.analyze.align*
6. bold.analyze.tree
7. bold.analyze.diversity
8. bold.analyze.map
9. bold.export

*Function 5 is currently an internal function which requires external dependencies not included in the package. For their specific usage, please see the details provided below.*

### Note on API key

The function `bold.fetch` requires an `api key` in order to access and download all public + private user data. API key can be obtained by emailing the BOLD support (support@boldsystems.org). API key is needed only for the data retrieval and can be added directly within the function. Alternatively, it can be set up as an environmental variable using the 'Sys.setenv' function. 

```{r api_key setenv}
# The key can be added in place of "api.key" 
# Sys.setenv ("api_key"="api.key")
```

It can then be retrieved using `Sys.getenv` function directly or by storing it as another variable.

```{r api_key getenv}
# api.key <- Sys.getenv('api_key')
```


## Functions usage:

### 1.bold.fields.info: 
`bold.fields.info` provides all the metadata related to the various fields (columns) currently available for download from BOLD. The function gives the name, definition and the data type of each field.
```{r bold.field.info,warning=FALSE,message=F}

bold.field.info<-bold.fields.info(print.output = FALSE)

knitr::kable(head(bold.field.info,5))

```

### 2.bold.fetch: 
This function retrieves public and private user data on BOLD using the`api key`.The downloaded data can also be filtered using the various filter arguments available (all `filt` arguments after the `api_key`). The filtering happens locally after the data is downloaded. Care has to be taken to select the filters properly. If wrong/too many filters are applied, it can result in an empty result. The `filt.fields` argument in the function helps in selecting only the fields needed by the user.

#### *Test data*
Test data is a data frame having 2 columns and 2100 unique ids. First column has 'processids' while second has 'sampleids'. Either one can be used to retrieve data from BOLD. 
```{r test data}

knitr::kable(head(test.data,5))

```

```{r key, include=F}
api.key<-"32E46B8E-FFD1-4A72-A0AB-B0CAB29BD5A1"

```

#### 2a.Default(all data retrieved)
The arguments provided below need to be specified by default for every request. Default settings retrieve data for all available fields for those ids. 
```{r bold.fetch,include=T}

# A small subset of the data used for data retrieval
trial.data=test.data[1:100,]

result<-bold.fetch(param.data = trial.data,
                   query.param = 'processid',
                   param.index = 1,
                   api_key = api.key)

# Results (First 5 rows)
knitr::kable(head(result,5))
```
#### 2b.Institutes Filter
Data is downloaded followed by the 'institute' filter applied on it to fetch only the relevant 'institute' (here South African Institute for Aquatic Biodiversity) data.
```{r bold.connectr filters1}

# A small subset of the data used for data retrieval
result_institutes<-bold.fetch(param.data = test.data,
                               query.param = 'processid',
                               param.index = 1,
                               api_key = api.key,
                               filt.institutes = c("Centre for Biodiversity Genomics"),
                              filt.fields = c("processid","sampleid","inst","nuc_basecount"))

# Results (first five rows)
knitr::kable(head(result_institutes,5))
```
#### 2c.Geographic location filter
Data is downloaded followed by the 'geography' filter applied on it to fetch only the relevant locations (here United States) data.
```{r bold.connectr filters2}

trial.data=test.data[1:100,]

result_geography<-bold.fetch(param.data = trial.data,
                               query.param = 'processid',
                               param.index = 1,
                               api_key = api.key,
                                filt.geography=c("Churchill"),
                                filt.fields = c("bin_uri","processid","region"))
# Result (First 5 rows) 
knitr::kable(head(result_geography,5))                 

```
#### 2d.Altitude
Data is downloaded followed by the 'Altitude' filter applied on it to fetch data only between the range of altitude specified (100 to 1500 m a.s.l.) data.
```{r bold.connectr filters3}

trial.data=test.data[1:100,]

result_altitude<-bold.fetch(param.data = trial.data,
                               query.param = 'processid',
                               param.index = 1,
                               api_key = api.key,
                               filt.altitude = c(1000,1200),
                               filt.fields = c("bin_uri","processid","family","elev"))

# Result (First 5 rows)
knitr::kable(head(result_altitude,5))                    
```

### 3.bold.search.public
This function retrieves the ids (process and sample id) of all publicly available data based on a search query. NO `api key` is required for this function. `bold.fetch` can then download all the relevant data for these ids. This two step process ensures that user has an idea on the scope of the data (i.e. number of records) based on the ids downloaded. Search can be based on taxonomic names, geographical locations, BIN ids (BIN numbers). All the other filters can then be used on the downloaded data to refine the result further.
*The search parameters of this function should be used carefully. Wrong combination of parameters might not retrieve any data.*

#### 3a.IDs retrieved based on taxonomy
```{r bold.connectr.public,warning=FALSE,message=FALSE}

result.public.ids<-bold.public.search(taxonomy = c("Panthera leo"))

# Result(First 5 rows)
knitr::kable(head(result.public.ids,5))                    
```
#### 3b.IDs retrieved based on taxonomy and geography
```{r bold.connectr.public2,warning=FALSE,message=FALSE}

result.public.geo.id<-bold.public.search(taxonomy = c("Panthera leo"),geography = "India",filt.marker = "COI-5P")

fetch.data.result.geo.id<-bold.fetch(param.data = result.public.geo.id,
                               query.param = 'processid',
                               param.index = 1,
                               api_key = api.key,
                               filt.fields = c("bin_uri","processid","family","elev"))

# Result(First 5 rows)
knitr::kable(head(fetch.data.result.geo.id,5)) 

```
#### 3c.IDs retrieved based on taxonomy, geography and BIN id
```{r bold.connectr.public3,warning=FALSE,message=FALSE}
result.public.geo.bin<-bold.public.search(taxonomy = c("Panthera leo"),geography = "India",bins = 'BOLD:AAD6819')

# Result(First 5 rows) 
knitr::kable(head(result.public.geo.bin))                   
```

### 4.bold.data.summarize
`bold.data.summarize` provides a detailed profile of the data downloaded through `bold.fetch`. This profile is further broken by data types wherein each type of data get some unique measures (Ex.mean,mode for numeric data). Profile can also be created for specific columns using the `columns` argument. The function also prints the number of rows and columns in the console by default.
```{r data summary,warning=FALSE,message=FALSE}
to_download=test.data[1:100,]

fetch.data.result.summ<-bold.fetch(param.data = to_download,
                               query.param = 'processid',
                               param.index = 1,
                               api_key = api.key,
                               filt.fields = c("bin_uri","elev","nuc_basecount","species","inst"))

data.summ.res<-bold.data.summarize(fetch.data.result.summ)

# Result: Data summary (character data)
data.summ.res$character


```


### *5.bold.analyze.align*
This function is currently an internal function of the package (with documentation). This function acts as a wrapper around the `msa` and `Biostrings` package functions for users of `BOLDconnectR` by which they can carry out multiple sequence alignment on the downloaded data by `bold.fetch` functions. In order to use this function following notation needs to be used `BOLDconnectR:::align.seq`. In addition, the users need to install and load `msa` and `Biostrings` separately before using this function to avoid any errors. A function performs alignment using the 'ClustalOmega' algorithm by default, though, more refined alignments  can be done by passing additional arguments of the `msa` function to the function. The function outputs a modified BOLD BCDM dataset with two additional columns, one being the aligned sequence and the other being the name of the sequence as per the user specifications. 
```{r align.seq,warning=FALSE,message=FALSE}

data.4.alignment.ids<-bold.public.search(taxonomy = "Eulimnadia")

aligned.data.result<-bold.fetch(param.data = data.4.alignment.ids,
                               query.param = 'processid',
                               param.index = 1,
                               api_key = api.key,
                               filt.marker = "COI-5P")

data.seq.aligned<-BOLDconnectR:::bold.analyze.align(aligned.data.result,align.method = "ClustalOmega")

# Subset of the BCDM data frame of the  aligned sequences and their respective names
 
final.res=subset(data.seq.aligned,select=c(aligned_seq,msa.seq.name))

# Result(First 5 rows)
knitr::kable(head(final.res))
```


### 6.bold.analyze.tree
This function uses the modified BCDM dataframe obtained from the `bold.analyze.align` to generate a distance matrix, a Neighbor Joining (NJ) tree visualization and a newick tree output. This function acts as a wrapper around the `dist.dna` and `plot.phylo` functions from `ape`. Additional arguments can be passed to the `dist.dna` function using the `...` argument. Newick trees can be exported optionally.

```{r analyze.seq,fig.width=6, fig.height=4, fig.align='center',warning=FALSE,message=FALSE}

data.4.analysis.ids<-bold.public.search(taxonomy = "Eulimnadia")
 
data.4.seqanalysis<-bold.fetch(param.data = data.4.analysis.ids,
                               query.param = 'processid',
                               param.index = 1,
                               api_key = api.key,
                               filt.marker = "COI-5P")

data.seq.align<-BOLDconnectR:::bold.analyze.align(data.4.seqanalysis,seq.name.fields = c("bin_uri","species"),align.method = "ClustalOmega")

data.seq.analyze<-bold.analyze.tree(data.seq.align,
                                             dist.model = "K80",
                                             dist.matrix = TRUE,
                                             clus.method="njs",
                                             tree.plot=TRUE,
                                             tree.plot.type = "p")


```


### 7. bold.analyze.diversity
`bold.analyze.diversity` generates a biodiversity profile of the BOLD BCDM downloaded data using the `bold.fetch` function. Results include, richness estimations, shannon diversity, preston plots and beta diversity. Function converts the data into a `site X species` like matrix (for more information, please scroll till the end) having either BIN counts (or presence-absence) data at the user-specified taxonomic level. This function acts as a wrapper function around `BAT::alpha.accum()`, `vegan::prestondistr()` and `vegan::diversity()` to calculate the results. Preston plots are created using the data from the `prestondistr` results where cyan bars represent observed species (or equivalent taxonomic group) and orange dots for expected the counts. Beta diversity is based on either the Sørensen or Jaccard indexes. It also generates matrices of *species replacement* and *richness difference* components of the total beta diversity. These values are calculated using `BAT::beta()` function, which partitions the data using the Podani & Schmera (2011)/Carvalho et al. (2012) approach. *Note that the results, including species counts, adapt based on taxonomic rank used in `gen.comm.mat()` although the output label remains ‘species’ in some instances (preston.res).*

#### 7a. Richness results
```{r alphadiv,fig.width=6, fig.align='center',warning=FALSE,message=FALSE}
# Fetch the data
BCDMdata<-bold.fetch(param.data = test.data,query.param = "processid",param.index = 1,api_key = api.key)

#1. Analyze richness data
res.rich<-bold.analyze.diversity(BCDMdata,taxon.rank="species",site.cat='region',richness.res=TRUE)

# Community matrix (BCDM data converted to community matrix)
knitr::kable(head(res.rich$comm.matrix,5))

# Richness results (top 10 rows)
knitr::kable(head(res.rich$richness,5))

```

#### 7b. Shannon diversity
```{r alphadiv2,fig.width=6, fig.align='center',warning=FALSE,message=FALSE}
#2. Shannon diversity
res.shannon<-bold.analyze.diversity(BCDMdata,taxon.rank="species",site.cat='region',shannon.res = TRUE)

# Shannon diversity results (top 10 rows)
knitr::kable(head(res.shannon$Shannon_div,5))

```
#### 7c. Preston plot results
```{r alphadiv3,fig.width=6, fig.align='center',warning=FALSE,message=FALSE}

#3. Preston plots and results

pres.res<-bold.analyze.diversity(BCDMdata,taxon.rank="species",site.cat='region',preston.res=TRUE)

# Preston plot
pres.res$preston.plot

# Preston plot data
pres.res$preston.res

```
#### 7d. Beta diversity
```{r alphadiv4,fig.width=6, fig.align='center',warning=FALSE,message=FALSE}

#4. beta diversity
beta.res<-bold.analyze.diversity(BCDMdata,taxon.rank="species",site.cat='region',beta.res=TRUE,beta.index = "jaccard")

# # Total beta diversity matrix (10 rows)
knitr::kable(head(as.matrix(round(beta.res$total.beta,2)),5))

#Replacement
#beta.res$replace

#Richness difference
#beta.res$richnessd

```

### 8.bold.analyze.map
```{r visualize.geo,fig.width=8,fig.height=8, fig.align='center',warning=FALSE,message=FALSE}
#Download the ids for the data
map.data.ids<-bold.public.search(taxonomy = "Musca domestica")

# Fetch the data using the ids
map.data<-bold.fetch(param.data = map.data.ids,query.param = "processid",param.index = 1,api_key = api.key)

# Visualizing all occurrences
geo.viz<-bold.analyze.map(map.data)

# Visualizing occurrences in a specific country
geo.viz.country<-bold.analyze.map(map.data,country = "China")

#The `sf` dataframe of the downloaded data
# geo.viz$geo.df

# Visualization
# geo.viz$plot

```


### 9.bold.export
`bold.export` provides an export option for some of the sequence based outputs obtained by functions from *BOLDconnectR*. Sequence information downloaded using the `bold.fetch` or the aligned sequences obtained using `bold.analyze.align` can be exported as a fasta file for third party tool use (`export`='fas' or 'msa.fas'). Data downloaded by the `bold.fetch` can be directly used to export the unaligned fasta file while the modified dataframe obtained after using the `bold.analyze.align` is needed for exporting the multiple sequence alignment. Name for individual sequences in the unaligned fasta file output can be customized by using the fas.seq.name.fields argument. If more than one field is specified, the name will follow the sequence of the fields given in the vector. The multiple sequence aligned fasta file uses the same name given by the user in the bold.analyze.align function. In addition, the function also allows user edited data (in taxonomy,geography etc.) to be exported as a csv/tsv file while retaining its BCDM format. This functionality is added keeping in the mind the possibility of uploading data to BOLD using the package in the near future.The edits done to the BCDM data could be from any other R packages so long as it maintains the BCDM format.
```{r bold.export,warning=FALSE,message=FALSE}

#Download the ids for the data
# data.for.export.ids<-bold.public.search(taxonomy = "Poecilia reticulata",filt.basecount = c(500,600),filt.marker = "COI-5P")

# Fetch the data using the ids
# data.for.export<-bold.fetch(param.data = data.for.export.ids,query.param = "processid",param.index = 1,api_key = apikey)

# Align the data (using species", bin_uri & country.ocean as a composite name for each sequence)
# seq.align<-BOLDconnectR:::bold.analyze.align(data.for.export, seq.name.fields = c("processid","bin_uri"))

# Export the fasta file (unaligned) (Please note the input data here is the original BCDM data retrieved using bold.fetch)
# bold.export(data.for.export,export = "fas",fas.seq.name.fields = c("species","bin_uri","processid"),export.file.path = "file_path",export.file.name = "file_name")

# Export the multiple sequence alignment (Please note the input data here is the modified BCDM data after using bold.analyze.align)
# bold.export(seq.align,export = "msa.fas",fas.seq.name.fields = ("species","bin_uri","processid"),,export.file.path = "file_path",export.file.name = "file_name")

# Additionally, if the user modifies any content in the BCDM data using any other R function, that modified dataframe can also be exported using bold.fetch. This option has been provided considering a future option of uploading data directly to BOLD

```


## Note on the community matrix generated for `bold.analyze.diversity`
Each cell in the community matrix contains the counts (or abundances) of the specimens for whose sequences have an assigned BIN, in a given a site category (site.cat) or a grid (grids.cat). These counts can be generated at any taxonomic hierarchical level, applicable to one or multiple taxa including ’bin_uri’. The `site.cat` can refer to any geographic field, and metadata on these fields can be checked using the `bold.fields.info()`. If, `grids.cat` = TRUE, grids are generated based on BIN occurrence data (latitude, longitude) with grid size determined by the user in square meters using the gridsize argument. Rows lacking latitude and longitude data are removed, while NULL entries for `site.cat` are allowed if they have a latitude and longitude value. This is because grids are drawn based on the bounding boxes which only use latitude and longitude values. 

#### *BOLDconnectR* is able to fetch public as well as private user data very fast (~100k records in a minute on a fast wired connection) and also offers functionality for data transformation and analysis. 
