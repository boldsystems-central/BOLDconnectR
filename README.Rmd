---
output: github_document
always_allow_html: yes
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# BOLDconnectR

<!-- badges: start -->
<!-- badges: end -->

BOLDconnectR is a package designed for **retrieval**, **transformation** and **analysis** of the data available in the *Barcode Of Life Data Systems (BOLD)* database. This package provides the functionality to obtain public and private user data available in the database in the *Barcode Core Data Model (BCDM)* format. Data include information on the **taxonomy**,**geography**,**collection**,**identification** and **DNA sequence** of every submission. 

```{r necessary packages install,include=FALSE}
library(devtools)
library(utils)
library(base)
library(msa)
library(Biostrings)
```

## Installation

The package can be installed using `devtools::install_github` function from the `devtools` package in R (which needs to be installed before installing BOLDConnectR). *This package currently exists as a private repo and thus has an authorization token*.

```{r setup,warning=FALSE,message=F}

devtools::install_github("https://github.com/sameerpadhye/BOLDconnectR.git",
                         auth_token = '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')

```

```{r BOLDconnectR import,warning=FALSE,message=FALSE}
library(BOLDconnectR)
```

## BOLDconnectR currently has 10 functions:

1. bold.fields.info
2. bold.connectr
3. bold.connectr.public
4. data.summary
5. gen.comm.mat
6. analyze.alphadiv
7. analyze.betadiv
8. visualize.geo
9. *align.seq*
10. *analyze.seq*

*Functions 9 and 10 are currently internal functions which require external dependencies not included in the package. For their specific usage, please see the details provided below.*

### Note on API key

The function `bold.connectr` requires an `api key` in order to access and download all public + private user data. API key can be obtained by emailing the BOLD support (support@boldsystems.org). API key is needed only for the data retrieval and can be added directly within the function. Alternatively, it can be set up as an environmental variable using the 'Sys.setenv' function. 

```{r api_key setenv}
# The key can be added in place of "api.key" 
Sys.setenv ("api_key"="api.key")
```

It can then be retrieved using `Sys.getenv` function directly or by storing it as another variable.

```{r api_key getenv}
api.key <- Sys.getenv('api_key')
```

## Functions usage:

### 1.bold.fields.info: 
`bold.fields.info` provides all the metadata related to the various fields (columns) currently available for download from BOLD. The function gives the name, definition and the data type of each field.
```{r bold.field.info,warning=FALSE,message=F}

bold.field.info<-bold.fields.info(print.output = FALSE)

knitr::kable(head(bold.field.info,5))

```

### 2.bold.connectr: 
This function retrieves public and private user data on BOLD using the`api key`.The downloaded data can also be filtered using the various filter arguments available (all arguments after the `api_key`). The filtering happens locally after the data is downloaded. Care has to be taken to select the filters properly. If wrong/too many filters are applied, it can result in an empty result. The `fields` argument in the function helps in selecting only the fields needed by the user.

Test data
Test data is a data frame having 2 columns and 2100 unique ids. First column has 'processids' while second has 'sampleids'. Either one can be used to retrieve data from BOLD. 
```{r test data}

knitr::kable(head(test.data,5))

```

```{r key, include=F}
Sys.setenv('api_key'='CE89B5A8-5ABE-4FB5-AEC6-187786EB1ED6')
```


### 2a.Default (all data retrieved)
The arguments provided below need to be specified by default for every request. Default settings retrieve data for all available fields for those ids. 
```{r bold.connectr}
api.key <- Sys.getenv('api_key')
# A small subset of the data used for data retrieval
to_download=test.data[1:100,]

result<-bold.connectr(input.data = to_download,
                                  param = 'processid',
                                  param.index = 1,
                                  api_key = api.key)
knitr::kable(head(result,5))
```

### 2b.Institutes Filter
Data is downloaded followed by the 'institute' filter applied on it to fetch only the relevant 'institute' (here South African Institute for Aquatic Biodiversity) data.
```{r bold.connectr filters1}
api.key <- Sys.getenv('api_key')
# A small subset of the data used for data retrieval
result_institutes<-bold.connectr(input.data = to_download,
                                  param = 'processid',
                                  param.index = 1,
                                  api_key = api.key,
                      institutes = "South African Institute for Aquatic Biodiversity",
                      fields = c("bin_uri","processid","inst"))

knitr::kable(head(result_institutes,5))
```

### 2c.Geographic location filter
Data is downloaded followed by the 'geography' filter applied on it to fetch only the relevant locations (here United States) data.
```{r bold.connectr filters2}
api.key <- Sys.getenv('api_key')

to_download=test.data[1:100,]
result_geography<-bold.connectr(input.data = to_download,
                                  param = 'processid',
                                  param.index = 1,
                                  api_key = api.key,
                                 geography=c("United States"),
                                fields = c("bin_uri","processid","province.state"))
 
knitr::kable(head(result_geography,5))                 

```

### 2d.Altitude
Data is downloaded followed by the 'Altitude' filter applied on it to fetch data only between the range of altitude specified (100 to 1500 m a.s.l.) data.
```{r bold.connectr filters3}
api.key <- Sys.getenv('api_key')

result_altitude<-bold.connectr(input.data = test.data,
                                  param = 'processid',
                                  param.index = 1,
                                  api_key = api.key,
                                 altitude = c(100,1500),
                               fields = c("bin_uri","processid","family","elev"))

knitr::kable(head(result_altitude,5))                    
```

### 2e.Collection period
Data is downloaded followed by the 'Collection period' filter applied on it to fetch data only between the range of dates specified (2009-2010) data.
```{r bold.connectr filters4}
api.key <- Sys.getenv('api_key')
result_collection.per<-bold.connectr(input.data = test.data,
                                  param = 'processid',
                                  param.index = 1,
                                  api_key = api.key,
                                 collection.period = c( "1995-05-26","2010-01-13"),
                                 fields=c("bin_uri","processid","collection_date_start","collection_date_end"))

knitr::kable(head(result_collection.per,5))
```

### 3.bold.connectr.public
This function retrieves all the public available data based on the query. NO `api key` is required for this function.  It also differs from `bold.connectr` with respect to the way the data is fetched. Search can be based on Taxonomic names, geographical locations in addition to ids (processid and sampleid) and BINs (BIN numbers). All the other filters can then be used on the downloaded data to refine the result.
*The search parameters of `bold.connectr.public` should be used carefully if a filtered result (like above) is expected. Wrong combination of parameters might not retrieve any data.*

### 3a.All data retrieved based on taxonomy
```{r bold.connectr.public,warning=FALSE,message=FALSE}

result.public<-bold.connectr.public(taxonomy = c("Panthera leo"),fields = c("bin_uri","processid","genus","species"))

knitr::kable(head(result.public,10))                    
```

### 3b.All data retrieved based on taxonomy and geography
```{r bold.connectr.public2,warning=FALSE,message=FALSE}
result.public.geo<-bold.connectr.public(taxonomy = c("Panthera leo"),geography = "India",fields = c("bin_uri","processid","country.ocean","genus","species"))

knitr::kable(head(result.public.geo,5))                    
```


### 3c.All data retrieved based on taxonomy, geography and BIN id
```{r bold.connectr.public3,warning=FALSE,message=FALSE}
result.public.geo.bin<-bold.connectr.public(taxonomy = c("Panthera leo"),geography = "India",bins = 'BOLD:AAD6819',fields = c("bin_uri","country.ocean","genus","species"))
 
knitr::kable(head(result.public.geo.bin))                   
```


### 4.data.summary
`data.summary` provides a detailed profile of the data downloaded through `bold.connectr` or `bold.connectr.public`. This profile is further broken by data types wherein each type of data get some unique measures (Ex.mean,mode for numeric data). Profile can also be created for specific columns using the `columns` argument. The function also prints the number of rows and columns in the console by default.
```{r data summary,warning=FALSE,message=FALSE}
result.public.geo.bin<-bold.connectr.public(taxonomy = c("Mus musculus"),fields = c("bin_uri","country.ocean","genus","species"))
                    
data.summ.res<-data.summary(result.public.geo.bin)

# Data summary
data.summ.res
```

### 5.gen.comm.mat
`gen.comm.mat`transforms the `bold.connectr()` or `bold.connectr.public()` downloaded data into a **site X species** like matrix. Instead of species counts (or abundances) though, values in each cell are the counts (or abundances) BINs from the site category (*site.cat*) or a *grid*. These counts can be generated at any taxonomic hierarchical level for a single or multiple taxa (This can also be done for 'bin_uri'; the difference being that the numbers in each cell would be the number of times that respective BIN is found at a particular *site.cat* or *grid*). *site.cat* can be any of the geography fields (Meta data on fields can be checked using the `bold.fields.info()`). Alternatively, `grids` = TRUE will generate grids based on the BIN occurrence data (latitude, longitude) with the size of the grid determined by the user (in sq.m.). For grids generation, rows with no latitude and longitude data are removed (even if a corresponding *site.cat* information is available) while NULL entries for *site.cat* are allowed if they have a latitude and longitude value (This is done because grids are drawn based on the bounding boxes which only use latitude and longitude values).grids converts the Coordinate Reference System (CRS) of the data to a **Mollweide** projection by which distance based grid can be appropriately specified. A cell id is also given to each grid with the smallest number assigned to the lowest latitudinal point in the data. The cell ids can be changed as per the user by making changes in the `grids_final` `sf` data frame stored in the output. The grids can be visualized with `view.grids`=TRUE. The plot obtained is a visualization of the grid centroids with their respective names. *Please note that if the data has many closely located grids, visualization with view.grids can get confusing*. The argument `pre.abs` will convert the counts (or abundances) to 1 and 0. This data set can then directly be used as the input data for functions from packages like vegan for biodiversity analyses.
```{r gen.comm.mat,warning=FALSE,message=FALSE}

# Download data from BOLD
comm.mat.data<-bold.connectr.public(taxonomy = "Panthera")

# Generate the community matrix based on grids
comm.data.grid<-gen.comm.mat(comm.mat.data,taxon.rank="species",grids = TRUE,gridsize = 10000000)

grids_output<-comm.data.grid$grids

# Community matrix based on grids
knitr::kable(head(comm.data.grid$comm.matrix))

```

### 6.analyze.alphadiv
`analyze.alphadiv` estimates the richness and calculates the shannon diversity indexes from BIN counts (and/or presence-absence) data at the user-specified taxonomic level using the `comm.matrix` output of the `gen.comm.mat` function. It acts as a wrapper function around `BAT::alpha.accum()`, `vegan::prestondistr()` and `vegan::diversity()` to create a biodiversity profile. Preston plots are created using the data from the `prestondistr` results where cyan bars represent observed species (or equivalent taxonomic group) and orange dots for expected the counts. *Note that the results, including species counts, adapt based on taxonomic rank used in `gen.comm.mat()` although the output label remains ‘species’ in some instances (preston.res).*
```{r alphadiv,fig.width=6, fig.align='center',warning=FALSE,message=FALSE}

# Download data from BOLD (removing species with blanks)
comm.mat.data<-bold.connectr.public(taxonomy = "Poecilia")

# Remove rows which have no species data
comm.mat.data<-comm.mat.data[!comm.mat.data$species=="",]

# Generate the community matrix based on grids
comm.data.grid<-gen.comm.mat(comm.mat.data,taxon.rank="species",site.cat='country.ocean')

# Community matrix (result assigned to a new variable)
grid.data<-comm.data.grid$comm.matrix

# Diversity results with estimation curve and without preston results
div.res1<-analyze.alphadiv(grid.data,plot.curve=TRUE,curve.index="Jack1ab",curve.xval = "Sampl",preston.res = TRUE,pres.plot.y.label = "species")

# Species richness plot
div.res1$richness_plot

# Preston plot
div.res1$preston.plot

```


### 7.analyze.betadiv
`analyze.betadiv` calculates beta dissimilarity based on either the Sørensen or Jaccard indexes using the `comm.matrix` output of the `gen.comm.mat` function. It also generates matrices of *species replacement* and *richness difference* components of the total beta diversity. These values are calculated using `BAT::beta()` function, which partitions the data using the Podani & Schmera (2011)/Carvalho et al. (2012) approach. Additionally, a corresponding heatmap can be obtained when `heatmap`=TRUE. For grid-based heatmaps, grids are arranged based on their centroid distances, placing nearest grids closest together. For site categories, heatmap labels are arranged alphabetically. *Note that grid- based heatmaps require `grids` = TRUE and a spatial dataframe sf-object `grid.df` generated from the `gen.comm.mat` function, to be provided.*
```{r betadiv,fig.width=12,fig.height=12, fig.align='center',warning=FALSE,message=FALSE}

#Download data from BOLD (removing species with blanks)
comm.mat.data<-bold.connectr.public(taxonomy = "Poecilia")

#Generate the community matrix based on grids
comm.data.beta<-gen.comm.mat(comm.mat.data,taxon.rank="species",site.cat = "country.ocean")

#beta diversity with the heatmaps
beta.div.res2<-analyze.betadiv(comm.data.beta$comm.matrix,index="sorenson",heatmap = TRUE,component = "total")

# Total beta diversity matrix (10 rows)
knitr::kable(head(as.matrix(round(beta.div.res2$total.beta,2)),10))

# Heatmap visualization
beta.div.res2$heatmap.viz

```

### 8.visualize.geo

```{r visualize.geo,fig.width=8,fig.height=8, fig.align='center',warning=FALSE,message=FALSE}

#Download data
geo.data<-bold.connectr.public(taxonomy = "Musca domestica")

# Map visualization
geo.viz<-visualize.geo(geo.data,export = FALSE)

#The `sf` dataframe of the downloaded data
knitr::kable(head(geo.viz$geo.df))
```

### *9.align.seq*
This function is currently an internal function of the package (with documentation). This function acts as a wrapper around the `msa` and `Biostrings` package functions for users of `BOLDconnectR` by which they can carry out multiple sequence alignment on the downloaded data by `bold.connectr` and `bold.connectr.public` functions. In order to use this function following notation needs to be used `BOLDconnectR:::align.seq`. In addition, the users need to install and load `msa` and `Biostrings` separately before using this function to avoid any errors. A function performs alignment using the 'ClustalOmega' algorithm by default, though, more refined alignments  can be done by passing additional arguments of the `msa` function to `align.seq`. 
```{r align.seq,warning=FALSE,message=FALSE}

library(msa)

data.align<-bold.connectr.public(taxonomy = "Panthera leo")

data.seq.aligned<-BOLDconnectR:::align.seq(data.align,name.fields = c("bin_uri","species"))

# A data.frame of the sequences and their respective names
knitr::kable(head(data.seq.aligned$seq.df,10))

# ape DNAbin object
data.seq.aligned$ape_obj

```

### *10.analyze.seq*
This function along with `align.seq` is an internal function of the package (with documentation). This function acts as a wrapper around the `dist.dna` and `plot.phylo` functions from `ape` for users of `BOLDconnectR`. The users can analyse the multiple sequence alignment output from the `align.seq` to generate a distance matrix, a Neighbor Joining (NJ) tree visualization and a newick tree output. In order to use this function following notation needs to be used `BOLDconnectR:::analyze.seq`. In addition, the users need to install and load `msa` and `Biostrings` separately before using this function to avoid any errors. Additional arguments of `dist.dna` can be passed to `analyze.seq` for more robust analysis.
```{r analyze.seq,fig.width=6, fig.height=4, fig.align='center',warning=FALSE,message=FALSE}

data.align<-bold.connectr.public(taxonomy = "Eulimnadia")

data.seq.aligned<-BOLDconnectR:::align.seq(data.align,name.fields = c("bin_uri","species"))

data.seq.analyze<-BOLDconnectR:::analyze.seq(data.seq.aligned$msa.result,
                                             dist.model = "K80",
                                             clus="njs",
                                             plot=TRUE,
                                             plot.type = "p")

# Distance matrix (top 5 rows)
knitr::kable(head(as.matrix(data.seq.analyze$dist_matrix),5))

```

