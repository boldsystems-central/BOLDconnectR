#'Export files generated by BOLDconnectR
#'
#' @description
#'The function is used to export some of the output data generated by BOLDconnectR
#'
#' @param bold.df The data.frame either retrieved from [bold.fetch()],`bold.analyze.align` or a user modified BCDM dataset.
#' @param export A character input specifying the type of output required. Should be either of "mod.df","msa.fas" or "fas".
#' @param fas.seq.name.fields A single or multiple character vector indicating the column headers that should be used to name each sequence for the unaligned FASTA file. Default is NULL; in this case, only the processid is used as the name.
#' @param df.export.file.type A character value specifying the type of file to be exported for the modified dataframe. Currently ‘.csv’ and ‘.tsv’ options are available.
#' @param export.file.path A character value specifying the folder path where the file should be saved.
#' @param export.file.name A character value specifying the name of the exported file.
#
#' @details
#' `bold.export` offers an export option for some of the sequence-based outputs obtained from functions within the [BOLDconnectR] package. Sequence information downloaded using [bold.fetch()] or the aligned sequences obtained using `bold.analyze.align` can be exported as a FASTA file for any third party tool (via `export`=’fas’ or ’msa.fas’). Data fetched by [bold.fetch()] can be directly used to export the unaligned FASTA file, while the modified dataframe from `bold.analyze.align` is required for exporting the multiple sequence alignment.
#'The name for individual sequences in the unaligned FASTA file output can be customized by using the `fas.seq.name.fields` argument. If more than one field is specified, the name will follow the sequence of the fields given in the vector. The multiple sequence aligned FASTA file uses the same name provided by the user in the `bold.analyze.align` function. Additionally, this function allows for the export of user-edited data (in taxonomy, geography etc.) as a csv/tsv file while retaining its BCDM format. This functionality is developed with the future potential of uploading data to BOLD using the package. Edits to the BCDM data can be made using any other R packages so long as it maintains the BCDM format.
#'
#' @examples
#' \dontrun{
#' Download data
#' data_for_export_ids <- bold.public.search(taxonomy = "Poecilia reticulata",
#'                                           filt.basecount= c(500,600),
#'                                           filt.marker = "COI-5P")
#'
#' # Fetching the data using the ids
#' data_for_export <- bold.fetch(data_for_export_ids,
#'                               query.param = "processid",
#'                               param.index = 1,
#'                               api_key= apikey)
#'
#' # Align the data (using processid and bin_uri as fields for sequence names)
#' # Users need to install and load packages `msa` and `Biostrings` before using bold.analyze.align.
#'
#' seq.align<-bold.analyze.align(data_for_export,
#'                                              seq.name.fields = c("processid","bin_uri"),
#'                                              align.method = "ClustalOmega")
#' # Export the multiple sequence alignment
#' # Note the input data here is the modified BCDM data after using bold.analyze.align.
#' # file.path and file.name must be provided
#' bold.export(seq.align,export = "msa.fas",
#' export.file.path = "file_path",
#' export.file.name = "file_name")
#'
#' # Export the fasta file (unaligned)
#' # Note that input data is the original BCDM data retrieved using bold.fetch.
#' # file.path and file.name must be provided
#' bold.export(data_for_export, export= "fas",
#' fas.seq.name.fields = c("species","bin_uri","processid"),
#' export.file.path = "",
#' export.file.name = "")
#' }
#'
#' @returns It exports a .fas or a csv/tsv file based on the export argument.
#'
#' @importFrom utils write.table
#' @importFrom ape read.dna
#' @importFrom ape write.FASTA
#'
#' @export
#'
bold.export<-function(bold.df,
                      export=c("mod.df","msa.fas","fas"),
                      fas.seq.name.fields=NULL,
                      df.export.file.type=NULL,
                      export.file.path=NULL,
                      export.file.name=NULL)

{
  # Check if data is a data frame object

  if(is.data.frame(bold.df)==FALSE) {

    stop("Input is not a data frame")

    return(FALSE)

  }

# Check whether the data frame is empty

if(nrow(bold.df)==0) {

  stop("Dataframe is empty")

  return(FALSE)

}


switch(export,



       "mod.df" =

         {


         # Check if the necessary columns are present in the dataframe for further analysis

         if(any((c("processid","sampleid","country.ocean", "phylum") %in% names(bold.df)))==FALSE)

         {

           stop("processid,sampleid, country names and phylum column have to be present to be consistent with the BOLD upload criteria. Please re-check data")

           return(FALSE)

         }

         else

         {

           if(df.export.file.type=="csv")

           {


             utils::write.table(bold.df,
                                paste(export.file.path,
                                      "/",
                                      export.file.name,
                                      ".",
                                      df.export.file.type,
                                      sep=""),
                                sep = ",",
                                row.names = FALSE,
                                quote = FALSE)
           }

           else if (df.export.file.type=="tsv")

           {

             utils::write.table(bold.df,
                                paste(export.file.path,
                                      "/",
                                      export.file.name,
                                      ".",
                                      df.export.file.type,
                                      sep=""),
                                sep = "\t",
                                row.names = FALSE,
                                quote = FALSE)

           }

           else

             {

             stop("File types can either be csv or tsv. Please re-check the type")

           }

         }


         },

       "msa.fas" =

         {


           seq.data=bold.df%>%
             dplyr::filter(!is.na(nuc))%>%
             dplyr::filter(!is.null(nuc))%>%
             dplyr::mutate(nuc=gsub("-","",nuc))%>%
             dplyr::filter(nuc!="")%>%
             dplyr::select(matches("^processid$",ignore.case=TRUE),
                           matches("sampleid",ignore.case=TRUE),
                           matches("^bin_uri$",ignore.case=TRUE),
                           matches("^marker_code$",ignore.case=TRUE),
                           matches("^aligned_seq$",ignore.case=TRUE),
                           matches("^msa.seq.name$",ignore.case=TRUE))


           generate_ape_file<-function(data)

           {

             data$msa.seq.name=paste(">",data$msa.seq.name,sep="")


             seq.data.4.fasta<-paste0(data$msa.seq.name,
                                      "\n",
                                      data$aligned_seq)%>%
               unlist()


             result = ape::read.dna(textConnection(seq.data.4.fasta),
                                    format = "fasta")


             return(result)

           }


           ## Export the result as a fasta file.

           result=generate_ape_file(data = seq.data)


           ape::write.FASTA(result,
                            file=paste(export.file.path,
                                       "/",
                                       export.file.name,
                                       sep=""))


       },


       "fas" =


         {


           seq.data=bold.df%>%
             dplyr::select(matches("^processid$",ignore.case=TRUE),
                           matches("sampleid",ignore.case=TRUE),
                           matches("^bin_uri$",ignore.case=TRUE),
                           matches("^marker_code$",ignore.case=TRUE),
                           matches("^nuc$",ignore.case=TRUE),
                           all_of(fas.seq.name.fields))%>%
             dplyr::filter(!is.na(nuc))%>%
             dplyr::filter(!is.null(nuc))%>%
             dplyr::mutate(nuc=gsub("-","",nuc))%>%
             dplyr::filter(nuc!="")%>%
             dplyr::rowwise()%>%
             dplyr::mutate(across(all_of(fas.seq.name.fields),
                                  as.character))%>%
             dplyr::select(nuc,
                           all_of(fas.seq.name.fields))%>%
             dplyr::mutate(seq.name=paste0(paste(as.character(c_across(all_of(fas.seq.name.fields))),
                                                 collapse = "|")))%>%
             dplyr::ungroup()


           generate_ape_file<-function(data)

           {

             data$seq.name=paste(">",data$seq.name,sep="")


             seq.data.4.fasta<-paste0(data$seq.name,
                                      "\n",
                                      data$nuc)%>%
               unlist()


             result = ape::read.dna(textConnection(seq.data.4.fasta),
                                    format = "fasta")


             return(result)

           }


            # Export the result as a raw fasta file.

             result=generate_ape_file(data = seq.data)


             ape::write.FASTA(result,
                              file=paste(export.file.path,
                                         "/",
                                         export.file.name,
                                         sep=""))

           }


)


}
