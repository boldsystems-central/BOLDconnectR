#'Export files generated by BOLDconnectR
#'
#' @description
#'The function is used to export some of the output data generated by BOLDconnectR
#'
#' @param bold.df The data.frame either retrieved from [bold.fetch()],[bold.analyze.align()] or a user modified BCDM dataset.
#' @param export A character input specifying the type of output required. Should be either of "mod.df","msa.fas" or "fas".
#' @param fas.seq.name.fields A single or multiple character vector specifying the column headers which to be should be used to name each sequence in the fasta file. Default is NULL in which case, only the processid is used as a name.
#' @param df.export.file.type A character value specifying the type of file to be exported for the modified dataframe. Currently ‘.csv’ and ‘.tsv’ options are available.
#' @param export.file.path A character value specifying the folder path where the file should be saved.,
#' @param export.file.name A character value specifying the name of the exported file.
#
#' @details
#' `bold.export` provides an export option for some of the sequence based outputs obtained by functions from `BOLDconnectR`. Sequence information downloaded using the `bold.fetch.data` or the aligned sequences obtained using `bold.analyze.align` can be exported as a fasta file for third party tool use (`export`='fas' or 'msa.fas'). Data downloaded by the `bold.fetch` can be directly used to export the unaligned fasta file while the modified dataframe obtained after using the `bold.analyze.align` is needed for exporting the multiple sequence alignment. Name for individual sequences in the unaligned fasta file output can be customized by using the `fas.seq.name.fields` argument. If more than one field is specified, the name will follow the sequence of the fields given in the vector. The multiple sequence aligned fasta file uses the same name given by the user in the `bold.analyze.align` function. In addition, the function also allows user edited data (in taxonomy,geography etc.)  to be exported  as a csv/tsv file while retaining its BCDM format. This functionality is added keeping in the mind the possibility of uploading data to BOLD using the package in the near future.The edits done to the BCDM data could be from any other R packages so long as it maintains the BCDM format.
#' @returns It exports a `.fas` or a `csv/tsv` file based on the `export` argument.
#'
#' @examples
#' \dontrun{
#' # Download data
#' bold_data<-bold.connectr.public(taxonomy = "Oreochromis")
#'
#' # Generate summary for specific fields (cols)
#' test.data.summary<-data.summary(bold_data,cols = c("country.ocean","nuc_basecount","inst","elev"))
#'
#' # Character data fields summary
#' test.data.summary$character
#'
#' # Numerical data fields summary
#' test.data.summary$numeric
#' }
#'
#' @importFrom utils write.table
#' @importFrom ape read.dna
#' @importFrom ape write.FASTA
#'
#' @export
#'
bold.export<-function(bold.df,
                      export=c("mod.df","msa.fas","fas"),
                      fas.seq.name.fields=NULL,
                      df.export.file.type=NULL,
                      export.file.path=NULL,
                      export.file.name=NULL)

{
  # Check if data is a data frame object

  if(is.data.frame(bold.df)==FALSE) {

    stop("Input is not a data frame")

    return(FALSE)

  }

# Check whether the data frame is empty

if(nrow(bold.df)==0) {

  stop("Dataframe is empty")

  return(FALSE)

}


switch(export,



       "mod.df" =

         {


         # Check if the necessary columns are present in the dataframe for further analysis

         if(any((c("processid","sampleid","country.ocean", "phylum") %in% names(bold.df)))==FALSE)

         {

           stop("processid,sampleid, country names and phylum column have to be present to be consistent with the BOLD upload criteria. Please re-check data")

           return(FALSE)

         }

         else

         {

           if(df.export.file.type=="csv")

           {


             utils::write.table(bold.df,
                                paste(export.file.path,
                                      "/",
                                      export.file.name,
                                      ".",
                                      df.export.file.type,
                                      sep=""),
                                sep = ",",
                                row.names = FALSE,
                                quote = FALSE)
           }

           else if (df.export.file.type=="tsv")

           {

             utils::write.table(bold.df,
                                paste(export.file.path,
                                      "/",
                                      export.file.name,
                                      ".",
                                      df.export.file.type,
                                      sep=""),
                                sep = "\t",
                                row.names = FALSE,
                                quote = FALSE)

           }

           else

             {

             stop("File types can either be csv or tsv. Please re-check the type")

           }

         }


         },

       "msa.fas" =

         {


           seq.data=bold.df%>%
             dplyr::filter(!is.na(nuc))%>%
             dplyr::filter(!is.null(nuc))%>%
             dplyr::mutate(nuc=gsub("-","",nuc))%>%
             dplyr::filter(nuc!="")%>%
             dplyr::select(matches("^processid$",ignore.case=TRUE),
                           matches("sampleid",ignore.case=TRUE),
                           matches("^bin_uri$",ignore.case=TRUE),
                           matches("^marker_code$",ignore.case=TRUE),
                           matches("^aligned_seq$",ignore.case=TRUE),
                           matches("^msa.seq.name$",ignore.case=TRUE))


           generate_ape_file<-function(data)

           {

             data$msa.seq.name=paste(">",data$msa.seq.name,sep="")


             seq.data.4.fasta<-paste0(data$msa.seq.name,
                                      "\n",
                                      data$aligned_seq)%>%
               unlist()


             result = ape::read.dna(textConnection(seq.data.4.fasta),
                                    format = "fasta")


             return(result)

           }


           ## Export the result as a fasta file.

           result=generate_ape_file(data = seq.data)


           ape::write.FASTA(result,
                            file=paste(export.file.path,
                                       "/",
                                       export.file.name,
                                       sep=""))


       },


       "fas" =


         {


           seq.data=bold.df%>%
             dplyr::select(matches("^processid$",ignore.case=TRUE),
                           matches("sampleid",ignore.case=TRUE),
                           matches("^bin_uri$",ignore.case=TRUE),
                           matches("^marker_code$",ignore.case=TRUE),
                           #matches("^nuc_basecount$",ignore.case=TRUE),
                           matches("^nuc$",ignore.case=TRUE),
                           all_of(fas.seq.name.fields))%>%
             dplyr::filter(!is.na(nuc))%>%
             dplyr::filter(!is.null(nuc))%>%
             dplyr::mutate(nuc=gsub("-","",nuc))%>%
             dplyr::filter(nuc!="")%>%
             dplyr::rowwise()%>%
             dplyr::mutate(across(all_of(fas.seq.name.fields),
                                  as.character))%>%
             dplyr::select(nuc,
                           all_of(fas.seq.name.fields))%>%
             dplyr::mutate(seq.name=paste0(paste(as.character(c_across(all_of(fas.seq.name.fields))),
                                                 collapse = "|")))%>%
             dplyr::ungroup()


           generate_ape_file<-function(data)

           {

             data$seq.name=paste(">",data$seq.name,sep="")


             seq.data.4.fasta<-paste0(data$seq.name,
                                      "\n",
                                      data$nuc)%>%
               unlist()


             result = ape::read.dna(textConnection(seq.data.4.fasta),
                                    format = "fasta")


             return(result)

           }


            # Export the result as a raw fasta file.

             result=generate_ape_file(data = seq.data)


             ape::write.FASTA(result,
                              file=paste(export.file.path,
                                         "/",
                                         export.file.name,
                                         sep=""))

           }


)


}
